[
    {
        "title": "Fix the IndexError",
        "instructions": "This code tries to access an element out of range. Identify and fix the bug.\n\nIndex errors are common occurances when dealing with data. It's not rare to find your arays to be a smaller size than you expect, or code for. Dynamic options are available, but you will always deal with arrays.\n\nThis error is ranked #6 on the Top 25 Most Dangerous Software Weakness, by Common Weakness Enumeration(CWE).\n\n\n\nCommon weakness enumeration. CWE. (n.d.). https://cwe.mitre.org/top25/archive/2024/2024_cwe_top25.html",
        "code": "numbers = [1, 2, 3]\nprint(numbers[3])",
        "hint": "Remember list indices start at 0.",
        "funFact": "This error is ranked #6 on the Top 25 Most Dangerous Software Weakness, by Common Weakness Enumeration(CWE)."
    },
    {
        "title": "Debug a Logic Error",
        "instructions": "This factorial function returns the wrong result for n>1. Find and fix the logic.\n\nA factorial multiplies every integer from 1 through n, so your loop must include the final value n. In many languages—including Python—loops defined as “from A up to B” often stop just before B, leading to an “off-by-one” omission. Recognizing how your loop boundaries align with the mathematical definition is key whenever you use indexing or ranges",
        "code": "def factorial(n):\n    result = 1\n    for i in range(1, n):\n        result *= i\n    return result\n\nprint(factorial(5))  # Expect 120",
        "hint": "Range end value off by one."
    },
    {
        "title": "Handle ZeroDivisionError",
        "instructions": "This code divides elements but fails on zero. Add exception handling.\n\nIf you try to divide by 0, Python stops with an error. Surround the division in a try block and catch any division failures so the program can skip the bad value and keep running.\n\n",
        "code": "values = [10, 5, 0, 2]\nfor v in values:\n    print(100 // v)",
        "hint": "Wrap division in try/except to catch ZeroDivisionError."
    },
    {
        "title": "Trace with Print Statements",
        "instructions": "Use print-debugging to understand why the loop stops early.\n\nSometimes loops end sooner than you expect because of a break statement. Printing the loop index and value each time helps you see exactly when the break runs and why the loop stops.\n\nThis is a concept that remains relavent deep into most developer's careers. Given that, it's invaludable to become comfortable with it.",
        "code": "data = [3, 6, 9, 12]\nfor idx, val in enumerate(data):\n    if val > 10:\n        break\nprint('Processed', idx, 'elements')",
        "hint": "Print idx and val inside the loop to see iterations."
    }
]